<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>block fromatting Context</title>
</head>
<body>
<h1>bfc布局规则</h1>
内部的块级元素会在垂直方向，一个接一个地放置；<br>
块级元素垂直方向的距离由margin决定。属于同一个BFC的两个相邻的块级元素会发生margin合并，不属于同一个BFC的两个相邻的块级元素不会发生margin合并；<br>
每个元素的margin box的左边，与包含border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此；<br>
BFC的区域不会与float box重叠；<br>
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素；外面的元素也不会影响到容器里面的子元素；<br>
计算BFC的高度时，浮动元素也参与计算。<br>
<h3>格式化上下文是按照块级盒子布局</h3>
w3c对bfc的定义如下：<br>
浮动元素和绝对定位元素，非块级盒子的块级容器（例如：
inline-blocks,table-cells,table-captions）,以及overflow值不为visiable的块级盒子，都会为他们的内容创建新的BFC（块级格式化上下文）<br>
一个html要创建一个bfc，任意满足下列任意一个或多个：<br>
1.float的值不为none<br>
2.position的值不是static或者relative<br>
3.display的值是inline-block，table-cell，flex，table-caption或者inline-flex<br>
4.overflow的值不是visible<br>
BFC是一个独立的布局环境，其中元素布局是不受外界的影响，在bfc中，行盒和块盒（行盒由一行内联元素组成）都会垂直的压着父元素的边框排列。<br>

<div class="container">
  your content
</div>
在container中添加类似overflow:scroll,overflow:hidden,display:flex,float:left,display:table的规则来显示创建bfc。可能有副作用<br>
1.display:table可能引发响应性问题<br>
2.overflow:scroll可能产生多余的滚动条<br>
3.float:left将元素移至左侧，并被其他元素环境环绕<br>

***************************<br>
在bfc中，块盒和行盒都会垂直的沿着其父元素的边框排列。w3c的规范是：<br>
在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）
<div class="container" style="overflow: hidden;background-color: #f00;border:10px solid #000">
  <div style="background-color: #090;border:10px solid #009">1</div>
  <!-- <div style="float:left;">6</div> -->
  <div style="background-color: #090;border:10px solid #009;float:left;">2</div>
  <div>3</div>
  <div>4</div>
  <div style="background-color: #090;">5</div>
</div>
<h3>外边距折叠</h3>
常规布局时，盒子都是垂直排列，两者之间由各自的外边距所决定，但不是外边距只和<br>
1.两个相邻的外边距为正数，折叠结果为较大值<br>
2.都是负数时，为两者绝对值的最大值<br>
3.一正一负，为两者相加之和<br>
<h3>bfc可以做什么</h3>
避免外边距折叠<br>
bfc产生外边距折叠要满足：两个相邻元素要处于同一个bfc中。所以，两个元素在不同的bfc中。就能避免外边距折叠。
<div class="container">
    <p>Sibling 1</p>
    <p>Sibling 2</p>
    <p>Sibling 3</p>
</div>
<style>
.container {
  background-color: red;
  overflow: hidden; /* creates a block formatting context */
}
p {
  background-color: lightgreen;
  margin: 10px 0;
}
</style>
改为：<br>
<div class="container">
    <p>Sibling 1</p>
    <p>Sibling 2</p>
    <div class="newBFC">
        <p>Sibling 3</p>
    </div>
</div>
<style>
.container {
    background-color: red;
    overflow: hidden; /* creates a block formatting context */
}
p {
    margin: 10px 0;
    background-color: lightgreen;
}
.newBFC {
    overflow: hidden;  /* creates new block formatting context */
}
</style>
<h3>bfc包含浮动</h3>
浮动元素是会脱离文档流的(绝对定位元素会脱离文档流)。如果一个没有高度或者height是auto的容器的子元素是浮动元素，则该容器的高度是不会被撑开的。我们通常会利用伪元素(:after或者:before)来解决这个问题。BFC能包含浮动，也能解决容器高度不会被撑开的问题。<br>
<div class="container">
    <div>Sibling</div>
    <div>Sibling</div>
</div>
CSS：

.container {
  background-color: green;
}
.container div {
  float: left;
  background-color: lightgreen;
  margin: 10px;
}
改为：<br>
.container {
    overflow: hidden; /* creates block formatting context */
    background-color: green;
}
.container div {
    float: left;
    background-color: lightgreen;
    margin: 10px;
}
****************<br>
<h3>避免文字环绕</h3>
<div class="container">
    <div class="floated">
        Floated div
    </div>
    <p>
        Quae hic ut ab perferendis sit quod architecto, 
        dolor debitis quam rem provident aspernatur tempora
        expedita.
    </p>
</div>
再回顾一下W3C的描述：<br>

在BFC上下文中，每个盒子的左外侧紧贴包含块的左侧（从右到左的格式里，则为盒子右外侧紧贴包含块右侧），甚至有浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。<br>
因而，如果p元素创建一个新的BFC那它就不会再紧贴包含块的左侧了。
<h3>在多列布局中使用BFC</h3>
如果我们创建一个占满整个容器宽度的多列布局，在某些浏览器中最后一列有时候会掉到下一行。这可能是因为浏览器四舍五入了列宽从而所有列的总宽度会超出容器。但如果我们在多列布局中的最后一列里创建一个新的BFC，它将总是占据其他列先占位完毕后剩下的空间。<br>
<div class="container">
    <div class="column">column 1</div>
    <div class="column">column 2</div>
    <div class="column">column 3</div>
</div>
.column {
    width: 31.33%;
    background-color: green;
    float: left;
    margin: 0 1%;
}
/*  Establishing a new block formatting 
    context in the last column */
.column:last-child {
    float: none;
overflow: hidden; 
}
</body>
</html>